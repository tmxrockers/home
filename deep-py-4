import openpyxl
import os
import pandas as pd
from typing import List, Dict, Optional, Any

# Read metadata from Alteryx input
metadata_df = pd.read_excel("DataMasking.xlsx", sheet_name=0)

# Convert metadata into a dictionary grouped by Workflow Type, File Path, and Header Row
grouped_rules = metadata_df.groupby(["Workflow Type", "File Path", "Header Row"])


def mask_email(value: str) -> str:
    """Mask an email address while keeping the domain intact."""
    if isinstance(value, str) and "@" in value:
        username, domain = value.split("@", 1)
        masked_username = "".join("x" if c.isalpha() else c for c in username)
        return f"{masked_username}@{domain}"
    return value  # Return unchanged if not a valid email or not string


def apply_mask_value_filter(value: Any, masking_value_filter: Optional[str]) -> bool:
    """Apply a masking value filter to a value."""
    if masking_value_filter and pd.notna(masking_value_filter):
        try:
            return eval(masking_value_filter, {"value": str(value)})
        except Exception as e:
            print(f"Error evaluating masking value filter '{masking_value_filter}': {e}")
    return True  # Default to applying masking if no filter or error


def apply_constant_mask(column: pd.Series, mask_value: Any, masking_value_filter: Optional[str]) -> List[Any]:
    """Apply a constant mask to a column."""
    return [mask_value if apply_mask_value_filter(val, masking_value_filter) else val for val in column]


def apply_prefix_mask(column: pd.Series, mask_value: Any, masking_value_filter: Optional[str]) -> List[Any]:
    """Apply a prefix mask to a column."""
    return [f"{mask_value}{val}" if apply_mask_value_filter(val, masking_value_filter) else val for val in column]


def apply_suffix_mask(column: pd.Series, mask_value: Any, masking_value_filter: Optional[str]) -> List[Any]:
    """Apply a suffix mask to a column."""
    return [f"{val}{mask_value}" if apply_mask_value_filter(val, masking_value_filter) else val for val in column]


def apply_email_mask(column: pd.Series, masking_value_filter: Optional[str]) -> List[Any]:
    """Apply an email mask to a column."""
    return [mask_email(str(val)) if apply_mask_value_filter(val, masking_value_filter) and pd.notna(val) else val for val in column]


def apply_null_mask(column: pd.Series, masking_value_filter: Optional[str]) -> List[Any]:
    """Apply a null mask to a column."""
    return [None if apply_mask_value_filter(val, masking_value_filter) else val for val in column]


def apply_referenced_file_mask(
    column: pd.Series,
    referenced_data: List[Dict[str, Any]],
    condition_columns: List[str],
    referenced_columns: List[str],
    condition_type: str,
    main_df: pd.DataFrame,
    output_column: str,
) -> List[Any]:
    """Apply a referenced file mask to a column."""
    masked_column = []
    for idx, value in enumerate(column):
        match_found = False
        for ref_row in referenced_data:
            match = True
            for cond_col, ref_col in zip(condition_columns, referenced_columns):
                cond_value = main_df[cond_col].iloc[idx]
                if pd.isna(cond_value):
                    match = False
                    break
                if condition_type == "Equals" and ref_row.get(ref_col) != cond_value:
                    match = False
                    break
                elif condition_type == "Contains" and str(ref_row.get(ref_col, "")) not in str(cond_value):
                    match = False
                    break
            if match:
                masked_column.append(ref_row[output_column])
                match_found = True
                break
        if not match_found:
            masked_column.append(value)  # Keep original value if no match found
    return masked_column


def apply_masking_column(
    column: pd.Series,
    pattern: str,
    mask_value: Any,
    masking_value_filter: Optional[str],
    referenced_data: Optional[List[Dict[str, Any]]] = None,
    condition_columns: Optional[List[str]] = None,
    referenced_columns: Optional[List[str]] = None,
    condition_type: Optional[str] = None,
    main_df: Optional[pd.DataFrame] = None,
    output_column: Optional[str] = None,
) -> List[Any]:
    """Apply masking to an entire column based on the specified pattern."""
    if pattern == "Constant":
        return apply_constant_mask(column, mask_value, masking_value_filter)
    elif pattern == "Prefix":
        return apply_prefix_mask(column, mask_value, masking_value_filter)
    elif pattern == "Suffix":
        return apply_suffix_mask(column, mask_value, masking_value_filter)
    elif pattern == "Email":
        return apply_email_mask(column, masking_value_filter)
    elif pattern == "Null":
        return apply_null_mask(column, masking_value_filter)
    elif pattern == "Referenced File":
        if referenced_data is not None and condition_columns is not None and referenced_columns is not None and main_df is not None and output_column is not None:
            return apply_referenced_file_mask(column, referenced_data, condition_columns, referenced_columns, condition_type, main_df, output_column)
    return column.tolist()  # Default: No masking if pattern is unknown


def read_referenced_file(file_path: str, sheet_name: str) -> Optional[List[Dict[str, Any]]]:
    """Read the referenced file and return the data as a list of dictionaries."""
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb[sheet_name]
        headers = [cell.value for cell in sheet[1]]
        data = []
        for row in sheet.iter_rows(min_row=2):
            row_data = {}
            for idx, cell in enumerate(row):
                row_data[headers[idx]] = cell.value
            data.append(row_data)
        return data
    except Exception as e:
        print(f"Error reading referenced file {file_path}: {e}")
        return None


def mask_excel_file(file_path: str, header_row: int, rules: List[tuple]) -> None:
    """Mask Excel data while preserving formatting."""
    try:
        # Read the main dataset into a pandas DataFrame
        main_df = pd.read_excel(file_path, header=header_row - 1)

        # Add temporary columns for referenced-based masking
        for column_name, pattern, _, _, referenced_file_path, referenced_sheet, condition_column, referenced_column, _, include_in_output, _ in rules:
            if include_in_output == "No" and column_name not in main_df.columns:
                main_df[column_name] = None  # Add temporary column with None values

        # Process each masking rule
        for column_name, pattern, mask_value, masking_value_filter, referenced_file_path, referenced_sheet, condition_column, referenced_column, condition_type, include_in_output, output_column in rules:
            if column_name not in main_df.columns:
                print(f"Warning: Column '{column_name}' not found in the main dataset.")
                continue

            # Apply masking to the column
            if pattern == "Referenced File":
                referenced_data = read_referenced_file(referenced_file_path, referenced_sheet)
                condition_columns = str(condition_column).split(";") if pd.notna(condition_column) else []
                referenced_columns = str(referenced_column).split(";") if pd.notna(referenced_column) else []
                main_df[column_name] = apply_masking_column(
                    main_df[column_name], pattern, mask_value, masking_value_filter, referenced_data, condition_columns, referenced_columns, condition_type, main_df, output_column
                )
            else:
                main_df[column_name] = apply_masking_column(main_df[column_name], pattern, mask_value, masking_value_filter)

        # Remove columns marked as "No" in Include in Output?
        columns_to_remove = [column_name for column_name, _, _, _, _, _, _, _, _, include_in_output, _ in rules if include_in_output == "No"]
        main_df.drop(columns=columns_to_remove, inplace=True)

        # Save masked file using openpyxl to preserve formatting
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active

        # Write the masked data back to the Excel file
        for row_idx, row in enumerate(main_df.itertuples(index=False), start=header_row + 1):
            # Check for empty row using openpyxl
            excel_row = sheet[row_idx]
            if all(cell.value is None or str(cell.value).strip() == "" for cell in excel_row):
                print(f"Row {row_idx} is empty or contains only blank values (openpyxl). Exiting masking process.")
                break  # Exit the loop if the row is empty

            for col_idx, value in enumerate(row, start=1):
                sheet.cell(row=row_idx, column=col_idx, value=value)

        # Save masked file in a new folder
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)

        output_file = os.path.join(masked_folder, os.path.basename(file_path))
        wb.save(output_file)

        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")


# Process each workflow type and file separately
for (workflow_type, file_path, header_row), group in grouped_rules:
    masking_rules = list(zip(
        group["Column Name"],
        group["Masking Pattern"],
        group["Masking Value"],
        group["Masking Value Filter"],
        group["Referenced Lookup File Path"],
        group["Referenced Lookup Sheet"],
        group["Condition Column"],
        group["Referenced Lookup Column"],
        group["Referenced Condition Type"],
        group["Include in Output? (Yes/No)"],
        group["Referenced Lookup Output Column"]
    ))
    mask_excel_file(file_path, int(header_row), masking_rules)










import openpyxl
import os
from typing import List, Dict, Optional, Any


def mask_email(value: str) -> str:
    """Mask an email address while keeping the domain intact."""
    if isinstance(value, str) and "@" in value:
        username, domain = value.split("@", 1)
        masked_username = "".join("x" if c.isalpha() else c for c in username)
        return f"{masked_username}@{domain}"
    return value  # Return unchanged if not a valid email or not string


def apply_mask_value_filter(value: Any, masking_value_filter: Optional[str]) -> bool:
    """Apply a masking value filter to a value."""
    if masking_value_filter and masking_value_filter.strip():
        try:
            return eval(masking_value_filter, {"value": str(value)})
        except Exception as e:
            print(f"Error evaluating masking value filter '{masking_value_filter}': {e}")
    return True  # Default to applying masking if no filter or error


def apply_constant_mask(value: Any, mask_value: Any, masking_value_filter: Optional[str]) -> Any:
    """Apply a constant mask to a value."""
    return mask_value if apply_mask_value_filter(value, masking_value_filter) else value


def apply_prefix_mask(value: Any, mask_value: Any, masking_value_filter: Optional[str]) -> Any:
    """Apply a prefix mask to a value."""
    return f"{mask_value}{value}" if apply_mask_value_filter(value, masking_value_filter) else value


def apply_suffix_mask(value: Any, mask_value: Any, masking_value_filter: Optional[str]) -> Any:
    """Apply a suffix mask to a value."""
    return f"{value}{mask_value}" if apply_mask_value_filter(value, masking_value_filter) else value


def apply_email_mask(value: Any, masking_value_filter: Optional[str]) -> Any:
    """Apply an email mask to a value."""
    return mask_email(str(value)) if apply_mask_value_filter(value, masking_value_filter) and value else value


def apply_null_mask(value: Any, masking_value_filter: Optional[str]) -> Any:
    """Apply a null mask to a value."""
    return None if apply_mask_value_filter(value, masking_value_filter) else value


def apply_referenced_file_mask(
    value: Any,
    referenced_data: List[Dict[str, Any]],
    condition_columns: List[str],
    referenced_columns: List[str],
    condition_type: str,
    row_data: Dict[str, Any],
    output_column: str,
) -> Any:
    """Apply a referenced file mask to a value."""
    for ref_row in referenced_data:
        match = True
        for cond_col, ref_col in zip(condition_columns, referenced_columns):
            cond_value = row_data.get(cond_col)
            ref_value = ref_row.get(ref_col)
            if cond_value is None or ref_value is None:
                match = False
                break
            if condition_type == "Equals" and str(ref_value).lower() != str(cond_value).lower():
                match = False
                break
            elif condition_type == "Contains" and str(ref_value).lower() not in str(cond_value).lower():
                match = False
                break
        if match:
            return ref_row.get(output_column, value)  # Return the referenced value if a match is found
    return value  # Return the original value if no match is found


def read_referenced_file(file_path: str, sheet_name: str) -> Optional[List[Dict[str, Any]]]:
    """Read the referenced file and return the data as a list of dictionaries."""
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb[sheet_name]
        headers = [cell.value for cell in sheet[1]]
        data = []
        for row in sheet.iter_rows(min_row=2, values_only=True):
            row_data = {headers[idx]: value for idx, value in enumerate(row)}
            data.append(row_data)
        return data
    except Exception as e:
        print(f"Error reading referenced file {file_path}: {e}")
        return None


def mask_excel_file(file_path: str, header_row: int, rules: List[tuple]) -> None:
    """Mask Excel data while preserving formatting."""
    try:
        # Load the workbook and active sheet
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active

        # Read the header row to get column names
        headers = [cell.value for cell in sheet[header_row]]

        # Add temporary columns for referenced-based masking
        for column_name, pattern, _, _, referenced_file_path, referenced_sheet, condition_column, referenced_column, _, include_in_output, _ in rules:
            if include_in_output == "No" and column_name not in headers:
                # Add temporary column with None values
                headers.append(column_name)
                sheet.cell(row=header_row, column=len(headers), value=column_name)

        # Process each row below the header
        for row in sheet.iter_rows(min_row=header_row + 1, values_only=False):
            row_data = {headers[idx]: cell.value for idx, cell in enumerate(row)}

            # Apply each masking rule
            for column_name, pattern, mask_value, masking_value_filter, referenced_file_path, referenced_sheet, condition_column, referenced_column, condition_type, include_in_output, output_column in rules:
                if column_name not in headers:
                    print(f"Warning: Column '{column_name}' not found in the main dataset.")
                    continue

                value = row_data.get(column_name)
                if pattern == "Constant":
                    new_value = apply_constant_mask(value, mask_value, masking_value_filter)
                elif pattern == "Prefix":
                    new_value = apply_prefix_mask(value, mask_value, masking_value_filter)
                elif pattern == "Suffix":
                    new_value = apply_suffix_mask(value, mask_value, masking_value_filter)
                elif pattern == "Email":
                    new_value = apply_email_mask(value, masking_value_filter)
                elif pattern == "Null":
                    new_value = apply_null_mask(value, masking_value_filter)
                elif pattern == "Referenced File":
                    referenced_data = read_referenced_file(referenced_file_path, referenced_sheet)
                    condition_columns = condition_column.split(";") if condition_column else []
                    referenced_columns = referenced_column.split(";") if referenced_column else []
                    new_value = apply_referenced_file_mask(
                        value, referenced_data, condition_columns, referenced_columns, condition_type, row_data, output_column
                    )
                else:
                    new_value = value  # Default: No masking if pattern is unknown

                # Update the cell value
                cell = row[headers.index(column_name)]
                cell.value = new_value

        # Remove columns marked as "No" in Include in Output?
        columns_to_remove = [column_name for column_name, _, _, _, _, _, _, _, _, include_in_output, _ in rules if include_in_output == "No"]
        for column_name in columns_to_remove:
            if column_name in headers:
                col_idx = headers.index(column_name) + 1  # Convert to 1-based index
                sheet.delete_cols(col_idx)
                headers.remove(column_name)

        # Save masked file in a new folder
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)

        output_file = os.path.join(masked_folder, os.path.basename(file_path))
        wb.save(output_file)

        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")


def main():
    """Main function to process masking rules."""
    # Load metadata from the Excel file
    metadata_wb = openpyxl.load_workbook("DataMasking.xlsx")
    metadata_sheet = metadata_wb.active

    # Read metadata headers
    metadata_headers = [cell.value for cell in metadata_sheet[1]]

    # Group rules by Workflow Type, File Path, and Header Row
    grouped_rules = {}
    for row in metadata_sheet.iter_rows(min_row=2, values_only=True):
        workflow_type, file_path, header_row = row[0], row[1], row[2]
        key = (workflow_type, file_path, header_row)
        if key not in grouped_rules:
            grouped_rules[key] = []
        grouped_rules[key].append(row)

    # Process each group of rules
    for (workflow_type, file_path, header_row), rules in grouped_rules.items():
        masking_rules = []
        for rule in rules:
            masking_rules.append((
                rule[metadata_headers.index("Column Name")],
                rule[metadata_headers.index("Masking Pattern")],
                rule[metadata_headers.index("Masking Value")],
                rule[metadata_headers.index("Masking Value Filter")],
                rule[metadata_headers.index("Referenced Lookup File Path")],
                rule[metadata_headers.index("Referenced Lookup Sheet")],
                rule[metadata_headers.index("Condition Column")],
                rule[metadata_headers.index("Referenced Lookup Column")],
                rule[metadata_headers.index("Referenced Condition Type")],
                rule[metadata_headers.index("Include in Output? (Yes/No)")],
                rule[metadata_headers.index("Referenced Lookup Output Column")],
            ))
        mask_excel_file(file_path, int(header_row), masking_rules)


if __name__ == "__main__":
    main()
