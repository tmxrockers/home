import openpyxl
import pandas as pd
import os

# Load Alteryx input data (passed from the Alteryx workflow)
df = Alteryx.read("#1")  # Read dataset from Input Tool

# Convert to dictionary grouped by Workflow Type and File Path
grouped_rules = df.groupby(["Workflow Type", "File Path", "Header Row"])

def mask_excel_file(file_path, header_row, rules):
    """
    Mask the given Excel file based on the rules provided and store it in a new folder.

    :param file_path: Path to the Excel file.
    :param header_row: The row number where headers exist (1-based index).
    :param rules: Dictionary mapping column names to masking patterns.
    """
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active  

        # Identify columns based on the given header row
        headers = [cell.value for cell in sheet[header_row]]
        column_indices = {col: idx + 1 for idx, col in enumerate(headers)}

        # Apply masking rules
        for row in sheet.iter_rows(min_row=header_row + 1):  
            for column_name, mask_rule in rules.items():
                col_idx = column_indices.get(column_name)
                if col_idx:
                    cell = row[col_idx - 1]
                    if cell.value:
                        # Apply masking pattern
                        if "{value}" in mask_rule:
                            cell.value = mask_rule.replace("{value}", str(cell.value))
                        elif "{last4}" in mask_rule:
                            cell.value = f"XXXX-{str(cell.value)[-4:]}" if len(str(cell.value)) >= 4 else "XXXX"
                        else:
                            cell.value = mask_rule  # Use fixed value

        # Create a new folder in the same location as the original file
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)  # Create folder if it doesn't exist

        # Save masked file in the new folder
        output_file = os.path.join(masked_folder, "masked_" + os.path.basename(file_path))
        wb.save(output_file)
        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")

# Process each workflow type and file separately
for (workflow_type, file_path, header_row), group in grouped_rules:
    # Create masking rule dictionary for this file
    masking_rules = dict(zip(group["Column Name"], group["Masking Pattern"]))
    
    # Mask the Excel file
    mask_excel_file(file_path, int(header_row), masking_rules)








import openpyxl
import pandas as pd
import os

# Load the metadata file (update the path accordingly)
metadata_file = "metadata.xlsx"
metadata_df = pd.read_excel(metadata_file)

# Convert metadata into a dictionary grouped by Workflow Type and File Path
grouped_rules = metadata_df.groupby(["Workflow Type", "File Path", "Header Row"])

def mask_excel_file(file_path, header_row, rules):
    """
    Mask the given Excel file based on the rules provided and store it in a new folder.

    :param file_path: Path to the Excel file.
    :param header_row: The row number where headers exist (1-based index).
    :param rules: Dictionary mapping column names to masking values.
    """
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active  

        # Identify columns based on the given header row
        headers = [cell.value for cell in sheet[header_row]]
        column_indices = {col: idx + 1 for idx, col in enumerate(headers)}

        # Apply masking rules
        for row in sheet.iter_rows(min_row=header_row + 1):  
            for column_name, mask_value in rules.items():
                col_idx = column_indices.get(column_name)
                if col_idx:
                    cell = row[col_idx - 1]
                    if cell.value:  # Only mask non-empty values
                        cell.value = mask_value  # Use the masking value from metadata

        # Create a new folder in the same location as the original file
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)  # Create only if not exists

        # Save masked file with the same name inside the new folder
        output_file = os.path.join(masked_folder, os.path.basename(file_path))
        wb.save(output_file)
        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")

# Process each workflow type and file separately
for (workflow_type, file_path, header_row), group in grouped_rules:
    # Create masking rule dictionary for this file from the metadata
    masking_rules = dict(zip(group["Column Name"], group["Masking Value"]))
    
    # Mask the Excel file
    mask_excel_file(file_path, int(header_row), masking_rules)




import openpyxl
import os
import pandas as pd
from ayx import Alteryx  # Alteryx-specific library

# Read metadata from Alteryx input
metadata_df = Alteryx.read("#1")  # "#1" is the first input in Alteryx

# Convert metadata into a dictionary grouped by Workflow Type and File Path
grouped_rules = metadata_df.groupby(["Workflow Type", "File Path", "Header Row"])

def mask_excel_file(file_path, header_row, rules):
    """
    Mask the given Excel file based on the rules provided and store it in a new folder.

    :param file_path: Path to the Excel file.
    :param header_row: The row number where headers exist (1-based index).
    :param rules: Dictionary mapping column names to masking values.
    """
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active  

        # Identify columns based on the given header row
        headers = [cell.value for cell in sheet[header_row]]
        column_indices = {col: idx + 1 for idx, col in enumerate(headers)}

        # Apply masking rules
        for row in sheet.iter_rows(min_row=header_row + 1):  
            for column_name, mask_value in rules.items():
                col_idx = column_indices.get(column_name)
                if col_idx:
                    cell = row[col_idx - 1]
                    if cell.value:  # Only mask non-empty values
                        cell.value = mask_value  # Use the masking value from metadata

        # Create a new folder in the same location as the original file
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)  # Create only if not exists

        # Save masked file with the same name inside the new folder
        output_file = os.path.join(masked_folder, os.path.basename(file_path))
        wb.save(output_file)
        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")

# Process each workflow type and file separately
for (workflow_type, file_path, header_row), group in grouped_rules:
    # Create masking rule dictionary for this file from the metadata
    masking_rules = dict(zip(group["Column Name"], group["Masking Value"]))
    
    # Mask the Excel file
    mask_excel_file(file_path, int(header_row), masking_rules)




import openpyxl
import os
import pandas as pd
from ayx import Alteryx  # Alteryx-specific library

# Read metadata from Alteryx input
metadata_df = Alteryx.read("#1")  # "#1" is the first input in Alteryx

# Convert metadata into a dictionary grouped by Workflow Type and File Path
grouped_rules = metadata_df.groupby(["Workflow Type", "File Path", "Header Row"])

def apply_masking(value, pattern, mask_value):
    """
    Apply the specified masking pattern to a given value.

    :param value: The original cell value.
    :param pattern: The masking pattern (Constant, Prefix, Suffix, Email, Null).
    :param mask_value: The value used for masking (if applicable).
    :return: Masked value.
    """
    if value is None or str(value).strip() == "":
        return value  # Do not mask empty cells

    if pattern == "Constant":
        return mask_value
    elif pattern == "Prefix":
        return f"{mask_value}{value}"
    elif pattern == "Suffix":
        return f"{value}{mask_value}"
    elif pattern == "Email":
        return f"masked_{value.split('@')[0]}@example.com" if "@" in str(value) else mask_value
    elif pattern == "Null":
        return None
    return value  # Default: No masking if pattern is unknown

def mask_excel_file(file_path, header_row, rules):
    """
    Mask the given Excel file based on the rules provided and store it in a new folder.

    :param file_path: Path to the Excel file.
    :param header_row: The row number where headers exist (1-based index).
    :param rules: List of tuples (column name, pattern, mask value).
    """
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active  

        # Identify columns based on the given header row
        headers = [cell.value for cell in sheet[header_row]]
        column_indices = {col: idx + 1 for idx, col in enumerate(headers)}

        # Apply masking rules
        for row in sheet.iter_rows(min_row=header_row + 1):  
            for column_name, pattern, mask_value in rules:
                col_idx = column_indices.get(column_name)
                if col_idx:
                    cell = row[col_idx - 1]
                    cell.value = apply_masking(cell.value, pattern, mask_value)

        # Create a new folder in the same location as the original file
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)  # Create only if not exists

        # Save masked file with the same name inside the new folder
        output_file = os.path.join(masked_folder, os.path.basename(file_path))
        wb.save(output_file)
        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")

# Process each workflow type and file separately
for (workflow_type, file_path, header_row), group in grouped_rules:
    # Create a list of masking rules for this file
    masking_rules = list(zip(group["Column Name"], group["Masking Pattern"], group["Masking Value"]))
    
    # Mask the Excel file
    mask_excel_file(file_path, int(header_row), masking_rules)


import openpyxl
import os
import pandas as pd
from ayx import Alteryx  # Alteryx-specific library

# Read metadata from Alteryx input
metadata_df = Alteryx.read("#1")  # "#1" is the first input in Alteryx

# Convert metadata into a dictionary grouped by Workflow Type and File Path
grouped_rules = metadata_df.groupby(["Workflow Type", "File Path", "Header Row"])

def mask_email(value):
    """
    Mask an email address by replacing part of the username while keeping the domain intact.

    :param value: The original email address.
    :return: Masked email address.
    """
    if "@" in value:
        username, domain = value.split("@", 1)
        masked_username = "".join("x" if c.isalpha() else c for c in username)  # Replace letters with 'x'
        return f"{masked_username}@{domain}"
    return value  # Return unchanged if not a valid email

def apply_masking(value, pattern, mask_value):
    """
    Apply the specified masking pattern to a given value.

    :param value: The original cell value.
    :param pattern: The masking pattern (Constant, Prefix, Suffix, Email, Null).
    :param mask_value: The value used for masking (if applicable).
    :return: Masked value.
    """
    if value is None or str(value).strip() == "":
        return value  # Do not mask empty cells

    if pattern == "Constant":
        return mask_value
    elif pattern == "Prefix":
        return f"{mask_value}{value}"
    elif pattern == "Suffix":
        return f"{value}{mask_value}"
    elif pattern == "Email":
        return mask_email(str(value))  # Apply email masking
    elif pattern == "Null":
        return None
    return value  # Default: No masking if pattern is unknown

def mask_excel_file(file_path, header_row, rules):
    """
    Mask the given Excel file based on the rules provided and store it in a new folder.

    :param file_path: Path to the Excel file.
    :param header_row: The row number where headers exist (1-based index).
    :param rules: List of tuples (column name, pattern, mask value).
    """
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active  

        # Identify columns based on the given header row
        headers = [cell.value for cell in sheet[header_row]]
        column_indices = {col: idx + 1 for idx, col in enumerate(headers)}

        # Apply masking rules
        for row in sheet.iter_rows(min_row=header_row + 1):  
            for column_name, pattern, mask_value in rules:
                col_idx = column_indices.get(column_name)
                if col_idx:
                    cell = row[col_idx - 1]
                    cell.value = apply_masking(cell.value, pattern, mask_value)

        # Create a new folder in the same location as the original file
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)  # Create only if not exists

        # Save masked file with the same name inside the new folder
        output_file = os.path.join(masked_folder, os.path.basename(file_path))
        wb.save(output_file)
        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")

# Process each workflow type and file separately
for (workflow_type, file_path, header_row), group in grouped_rules:
    # Create a list of masking rules for this file
    masking_rules = list(zip(group["Column Name"], group["Masking Pattern"], group["Masking Value"]))
    
    # Mask the Excel file
    mask_excel_file(file_path, int(header_row), masking_rules)





import openpyxl
import os
import pandas as pd
from ayx import Alteryx  # Alteryx-specific library

# Read metadata from Alteryx input
metadata_df = Alteryx.read("#1")  # "#1" is the first input in Alteryx

# Convert metadata into a dictionary grouped by Workflow Type and File Path
grouped_rules = metadata_df.groupby(["Workflow Type", "File Path", "Header Row"])

def mask_email(value):
    """Mask an email address while keeping the domain intact."""
    if "@" in value:
        username, domain = value.split("@", 1)
        masked_username = "".join("x" if c.isalpha() else c for c in username)
        return f"{masked_username}@{domain}"
    return value

def apply_masking(value, pattern, mask_value):
    """Apply different masking patterns."""
    if value is None or str(value).strip() == "":
        return value  # Do not mask empty cells

    if pattern == "Constant":
        return mask_value
    elif pattern == "Prefix":
        return f"{mask_value}{value}"
    elif pattern == "Suffix":
        return f"{value}{mask_value}"
    elif pattern == "Email":
        return mask_email(str(value))
    elif pattern == "Null":
        return None
    return value

def is_row_empty(row):
    """Check if all values in a row are NULL or empty."""
    return all(cell.value is None or str(cell.value).strip() == "" for cell in row)

def mask_excel_file(file_path, header_row, rules):
    """Mask Excel data while handling NULL row scenarios."""
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active  

        # Identify columns based on header row
        headers = [cell.value for cell in sheet[header_row]]
        column_indices = {col: idx + 1 for idx, col in enumerate(headers)}

        previous_row_empty = False  # Flag to track empty row condition

        # Apply masking rules
        for row in sheet.iter_rows(min_row=header_row + 1):  
            if is_row_empty(row):  
                previous_row_empty = True  # Mark row as empty
                continue  # Skip masking for empty rows

            if previous_row_empty:
                print("Skipping masking due to NULL row condition.")
                break  # Stop masking if previous row was empty

            for column_name, pattern, mask_value in rules:
                col_idx = column_indices.get(column_name)
                if col_idx:
                    cell = row[col_idx - 1]
                    cell.value = apply_masking(cell.value, pattern, mask_value)

        # Save masked file in a new folder
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)

        output_file = os.path.join(masked_folder, os.path.basename(file_path))
        wb.save(output_file)
        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")

# Process each workflow type and file
for (workflow_type, file_path, header_row), group in grouped_rules:
    masking_rules = list(zip(group["Column Name"], group["Masking Pattern"], group["Masking Value"]))
    mask_excel_file(file_path, int(header_row), masking_rules)




import openpyxl
import os
import pandas as pd
from ayx import Alteryx  # Alteryx-specific library for input/output

# Read metadata from Alteryx input
metadata_df = Alteryx.read("#1")  # "#1" represents the first Alteryx input

# Convert metadata into a dictionary grouped by Workflow Type and File Path
grouped_rules = metadata_df.groupby(["Workflow Type", "File Path", "Header Row"])

def mask_email(value):
    """Mask an email address while keeping the domain intact."""
    if "@" in value:
        username, domain = value.split("@", 1)
        masked_username = "".join("x" if c.isalpha() else c for c in username)
        return f"{masked_username}@{domain}"
    return value  # Return unchanged if not a valid email

def apply_masking(value, pattern, mask_value):
    """Apply different masking patterns."""
    if value is None or str(value).strip() == "":
        return value  # Do not mask empty cells

    if pattern == "Constant":
        return mask_value
    elif pattern == "Prefix":
        return f"{mask_value}{value}"
    elif pattern == "Suffix":
        return f"{value}{mask_value}"
    elif pattern == "Email":
        return mask_email(str(value))
    elif pattern == "Null":
        return None
    return value  # Default: No masking if pattern is unknown

def is_row_empty(row):
    """Check if all values in a row are NULL or empty."""
    return all(cell.value is None or str(cell.value).strip() == "" for cell in row)

def mask_excel_file(file_path, header_row, rules):
    """Mask Excel data while handling NULL row scenarios."""
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active  # Use the first sheet by default

        # Read headers as text (forcing string conversion)
        headers = [str(cell.value) for cell in sheet[header_row]]
        column_indices = {col: idx + 1 for idx, col in enumerate(headers)}

        previous_row_empty = False  # Flag to track empty row condition

        for row in sheet.iter_rows(min_row=header_row + 1):  
            if is_row_empty(row):  
                previous_row_empty = True  
                continue  # Skip masking for empty rows

            if previous_row_empty:
                print("Skipping masking due to NULL row condition.")
                break  # Stop masking if previous row was empty

            for column_name, pattern, mask_value in rules:
                col_idx = column_indices.get(column_name)
                if col_idx:
                    cell = row[col_idx - 1]
                    cell.value = apply_masking(cell.value, pattern, mask_value)

        # Save masked file in a new folder
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)  # Create only if not exists

        output_file = os.path.join(masked_folder, os.path.basename(file_path))

        # Ensure headers remain text
        for col_idx, col_name in enumerate(headers, start=1):
            sheet.cell(row=header_row, column=col_idx, value=str(col_name))  

        wb.save(output_file)
        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")

# Process each workflow type and file separately
for (workflow_type, file_path, header_row), group in grouped_rules:
    masking_rules = list(zip(group["Column Name"], group["Masking Pattern"], group["Masking Value"]))
    mask_excel_file(file_path, int(header_row), masking_rules)






import openpyxl
import os
import pandas as pd
from ayx import Alteryx  # Alteryx-specific library for input/output

# Read metadata from Alteryx input
metadata_df = Alteryx.read("#1")  # "#1" represents the first Alteryx input

# Convert metadata into a dictionary grouped by Workflow Type and File Path
grouped_rules = metadata_df.groupby(["Workflow Type", "File Path", "Header Row"])

def mask_email(value):
    """Mask an email address while keeping the domain intact."""
    if "@" in value:
        username, domain = value.split("@", 1)
        masked_username = "".join("x" if c.isalpha() else c for c in username)
        return f"{masked_username}@{domain}"
    return value  # Return unchanged if not a valid email

def apply_masking(value, pattern, mask_value):
    """Apply different masking patterns."""
    if value is None or str(value).strip() == "":
        return value  # Do not mask empty cells

    if pattern == "Constant":
        return mask_value
    elif pattern == "Prefix":
        return f"{mask_value}{value}"
    elif pattern == "Suffix":
        return f"{value}{mask_value}"
    elif pattern == "Email":
        return mask_email(str(value))
    elif pattern == "Null":
        return None
    return value  # Default: No masking if pattern is unknown

def is_row_empty(row):
    """Check if all values in a row are NULL or empty."""
    return all(cell.value is None or str(cell.value).strip() == "" for cell in row)

def mask_excel_file(file_path, header_row, rules):
    """Mask Excel data while handling NULL row scenarios."""
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active  # Use the first sheet by default

        # Read headers as text (forcing string conversion)
        headers = [str(cell.value) for cell in sheet[header_row]]
        column_indices = {col: idx + 1 for idx, col in enumerate(headers)}

        previous_row_empty = False  # Flag to track empty row condition

        for row in sheet.iter_rows(min_row=header_row + 1):  
            if is_row_empty(row):  
                previous_row_empty = True  
                continue  # Skip masking for empty rows

            if previous_row_empty:
                print("Skipping masking due to NULL row condition.")
                break  # Stop masking if previous row was empty

            for column_name, pattern, mask_value in rules:
                col_idx = column_indices.get(column_name)
                if col_idx:
                    cell = row[col_idx - 1]
                    cell.value = apply_masking(cell.value, pattern, mask_value)

        # Save masked file in a new folder
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)  # Create only if not exists

        output_file = os.path.join(masked_folder, os.path.basename(file_path))

        # âœ… Ensure headers remain as text
        for col_idx, cell in enumerate(sheet[header_row], start=1):
            if isinstance(cell.value, (int, float)):  # If Excel has converted it to a number (date format)
                cell.value = str(cell.value)  # Convert explicitly to a string
            else:
                cell.value = str(cell.value)  # Ensure all headers are treated as text

        wb.save(output_file)
        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")

# Process each workflow type and file separately
for (workflow_type, file_path, header_row), group in grouped_rules:
    masking_rules = list(zip(group["Column Name"], group["Masking Pattern"], group["Masking Value"]))
    mask_excel_file(file_path, int(header_row), masking_rules)



import openpyxl
import os
import pandas as pd
from ayx import Alteryx  # Alteryx-specific library for input/output

# Read metadata from Alteryx input
metadata_df = Alteryx.read("#1")  # "#1" represents the first Alteryx input

# Convert metadata into a dictionary grouped by Workflow Type and File Path
grouped_rules = metadata_df.groupby(["Workflow Type", "File Path", "Header Row"])

def mask_email(value):
    """Mask an email address while keeping the domain intact."""
    if "@" in value:
        username, domain = value.split("@", 1)
        masked_username = "".join("x" if c.isalpha() else c for c in username)
        return f"{masked_username}@{domain}"
    return value  # Return unchanged if not a valid email

def apply_masking(value, pattern, mask_value):
    """Apply different masking patterns."""
    if value is None or str(value).strip() == "":
        return value  # Do not mask empty cells

    if pattern == "Constant":
        return mask_value
    elif pattern == "Prefix":
        return f"{mask_value}{value}"
    elif pattern == "Suffix":
        return f"{value}{mask_value}"
    elif pattern == "Email":
        return mask_email(str(value))
    elif pattern == "Null":
        return None
    return value  # Default: No masking if pattern is unknown

def is_row_empty(row):
    """Check if all values in a row are NULL or empty."""
    return all(cell.value is None or str(cell.value).strip() == "" for cell in row)

def ensure_valid_headers(sheet, header_row):
    """Ensure headers are correctly formatted as strings to avoid Alteryx issues."""
    headers = []
    for cell in sheet[header_row]:
        if isinstance(cell.value, (int, float)):  
            cell.value = f"Column_{cell.column}"  # Rename numerical headers
        elif cell.value is None or str(cell.value).strip() == "":
            cell.value = f"Column_{cell.column}"  # Rename blank headers
        else:
            cell.value = str(cell.value).strip()  # Convert to string
        cell.number_format = "@"  # Force text format
        headers.append(cell.value)
    return headers

def mask_excel_file(file_path, header_row, rules):
    """Mask Excel data while handling NULL row scenarios."""
    try:
        wb = openpyxl.load_workbook(file_path)
        sheet = wb.active  # Use the first sheet by default

        headers = ensure_valid_headers(sheet, header_row)
        column_indices = {col: idx + 1 for idx, col in enumerate(headers)}

        previous_row_empty = False  # Flag to track empty row condition

        for row in sheet.iter_rows(min_row=header_row + 1):  
            if is_row_empty(row):  
                previous_row_empty = True  
                continue  # Skip masking for empty rows

            if previous_row_empty:
                print("Skipping masking due to NULL row condition.")
                break  # Stop masking if previous row was empty

            for column_name, pattern, mask_value in rules:
                col_idx = column_indices.get(column_name)
                if col_idx:
                    cell = row[col_idx - 1]
                    cell.value = apply_masking(cell.value, pattern, mask_value)

        # Save masked file in a new folder
        base_dir = os.path.dirname(file_path)
        masked_folder = os.path.join(base_dir, "Masked_Files")
        os.makedirs(masked_folder, exist_ok=True)  # Create only if not exists

        output_file = os.path.join(masked_folder, os.path.basename(file_path))

        wb.save(output_file)
        print(f"Masked file saved: {output_file}")

    except Exception as e:
        print(f"Error processing {file_path}: {e}")

# Process each workflow type and file separately
for (workflow_type, file_path, header_row), group in grouped_rules:
    masking_rules = list(zip(group["Column Name"], group["Masking Pattern"], group["Masking Value"]))
    mask_excel_file(file_path, int(header_row), masking_rules)